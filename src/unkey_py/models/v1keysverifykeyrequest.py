"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .permissionquery import PermissionQuery, PermissionQueryTypedDict
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict, deprecated
from unkey_py.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class AuthorizationTypedDict(TypedDict):
    r"""Perform RBAC checks"""

    permissions: NotRequired[Nullable[PermissionQueryTypedDict]]
    r"""A query for which permissions you require"""


class Authorization(BaseModel):
    r"""Perform RBAC checks"""

    permissions: OptionalNullable[PermissionQuery] = UNSET
    r"""A query for which permissions you require"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["permissions"]
        nullable_fields = ["permissions"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RemainingTypedDict(TypedDict):
    r"""Customize the behaviour of deducting remaining uses. When some of your endpoints are more expensive than others, you can set a custom `cost` for each."""

    cost: NotRequired[int]
    r"""How many tokens should be deducted from the current `remaining` value. Set it to 0, to make it free."""


class Remaining(BaseModel):
    r"""Customize the behaviour of deducting remaining uses. When some of your endpoints are more expensive than others, you can set a custom `cost` for each."""

    cost: Optional[int] = 1
    r"""How many tokens should be deducted from the current `remaining` value. Set it to 0, to make it free."""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class V1KeysVerifyKeyRequestRatelimitTypedDict(TypedDict):
    r"""Use 'ratelimits' with `[{ name: \"default\", cost: 2}]`"""

    cost: NotRequired[int]
    r"""Override how many tokens are deducted during the ratelimit operation."""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class V1KeysVerifyKeyRequestRatelimit(BaseModel):
    r"""Use 'ratelimits' with `[{ name: \"default\", cost: 2}]`"""

    cost: Optional[int] = 1
    r"""Override how many tokens are deducted during the ratelimit operation."""


class RatelimitsModelTypedDict(TypedDict):
    name: str
    r"""The name of the ratelimit."""
    cost: NotRequired[int]
    r"""Optionally override how expensive this operation is and how many tokens are deducted from the current limit."""
    limit: NotRequired[int]
    r"""Optionally override the limit."""
    duration: NotRequired[int]
    r"""Optionally override the ratelimit window duration."""


class RatelimitsModel(BaseModel):
    name: str
    r"""The name of the ratelimit."""

    cost: Optional[int] = 1
    r"""Optionally override how expensive this operation is and how many tokens are deducted from the current limit."""

    limit: Optional[int] = None
    r"""Optionally override the limit."""

    duration: Optional[int] = None
    r"""Optionally override the ratelimit window duration."""


class V1KeysVerifyKeyRequestTypedDict(TypedDict):
    key: str
    r"""The key to verify"""
    api_id: NotRequired[str]
    r"""The id of the api where the key belongs to. This is optional for now but will be required soon.
    The key will be verified against the api's configuration. If the key does not belong to the api, the verification will fail.
    """
    tags: NotRequired[List[str]]
    r"""Tags do not influence the outcome of a verification.
    They can be added to filter or aggregate historical verification data for your analytics needs.
    To unkey, a tag is simply a string, we don't enforce any schema but leave that up to you.
    The only exception is that each tag must be between 1 and 128 characters long.
    A typical setup would be to add key-value pairs of resources or locations, that you need later when querying.

    """
    authorization: NotRequired[AuthorizationTypedDict]
    r"""Perform RBAC checks"""
    remaining: NotRequired[RemainingTypedDict]
    r"""Customize the behaviour of deducting remaining uses. When some of your endpoints are more expensive than others, you can set a custom `cost` for each."""
    ratelimit: NotRequired[V1KeysVerifyKeyRequestRatelimitTypedDict]
    r"""Use 'ratelimits' with `[{ name: \"default\", cost: 2}]`"""
    ratelimits: NotRequired[List[RatelimitsModelTypedDict]]
    r"""You can check against multiple ratelimits when verifying a key. Let's say you are building an app that uses AI under the hood and you want to limit your customers to 500 requests per hour, but also ensure they use up less than 20k tokens per day.

    https://www.unkey.com/docs/concepts/identities/ratelimits
    """


class V1KeysVerifyKeyRequest(BaseModel):
    key: str
    r"""The key to verify"""

    api_id: Annotated[Optional[str], pydantic.Field(alias="apiId")] = None
    r"""The id of the api where the key belongs to. This is optional for now but will be required soon.
    The key will be verified against the api's configuration. If the key does not belong to the api, the verification will fail.
    """

    tags: Optional[List[str]] = None
    r"""Tags do not influence the outcome of a verification.
    They can be added to filter or aggregate historical verification data for your analytics needs.
    To unkey, a tag is simply a string, we don't enforce any schema but leave that up to you.
    The only exception is that each tag must be between 1 and 128 characters long.
    A typical setup would be to add key-value pairs of resources or locations, that you need later when querying.

    """

    authorization: Optional[Authorization] = None
    r"""Perform RBAC checks"""

    remaining: Optional[Remaining] = None
    r"""Customize the behaviour of deducting remaining uses. When some of your endpoints are more expensive than others, you can set a custom `cost` for each."""

    ratelimit: Annotated[
        Optional[V1KeysVerifyKeyRequestRatelimit],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""Use 'ratelimits' with `[{ name: \"default\", cost: 2}]`"""

    ratelimits: Optional[List[RatelimitsModel]] = None
    r"""You can check against multiple ratelimits when verifying a key. Let's say you are building an app that uses AI under the hood and you want to limit your customers to 500 requests per hour, but also ensure they use up less than 20k tokens per day.

    https://www.unkey.com/docs/concepts/identities/ratelimits
    """
