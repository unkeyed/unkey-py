"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .httpmetadata import HTTPMetadata, HTTPMetadataTypedDict
import pydantic
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from unkey_py.types import BaseModel, Nullable


class ResourcesTypedDict(TypedDict):
    type: str
    r"""The type of resource"""
    id: str
    r"""The unique identifier for the resource"""
    name: NotRequired[str]
    r"""A human readable name for this resource"""
    meta: NotRequired[Dict[str, Nullable[Any]]]
    r"""Attach any metadata to this resources"""


class Resources(BaseModel):
    type: str
    r"""The type of resource"""

    id: str
    r"""The unique identifier for the resource"""

    name: Optional[str] = None
    r"""A human readable name for this resource"""

    meta: Optional[Dict[str, Nullable[Any]]] = None
    r"""Attach any metadata to this resources"""


class LimitRequestBodyTypedDict(TypedDict):
    identifier: str
    r"""Identifier of your user, this can be their userId, an email, an ip or anything else."""
    limit: int
    r"""How many requests may pass in a given window."""
    duration: int
    r"""The window duration in milliseconds"""
    namespace: NotRequired[str]
    r"""Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes."""
    cost: NotRequired[int]
    r"""Expensive requests may use up more tokens. You can specify a cost to the request here and we'll deduct this many tokens in the current window.
    If there are not enough tokens left, the request is denied.

    Set it to 0 to receive the current limit without changing anything.
    """
    async_: NotRequired[bool]
    r"""Async will return a response immediately, lowering latency at the cost of accuracy."""
    meta: NotRequired[Dict[str, Nullable[Any]]]
    r"""Attach any metadata to this request"""
    resources: NotRequired[List[ResourcesTypedDict]]
    r"""Resources that are about to be accessed by the user"""


class LimitRequestBody(BaseModel):
    identifier: str
    r"""Identifier of your user, this can be their userId, an email, an ip or anything else."""

    limit: int
    r"""How many requests may pass in a given window."""

    duration: int
    r"""The window duration in milliseconds"""

    namespace: Optional[str] = "default"
    r"""Namespaces group different limits together for better analytics. You might have a namespace for your public API and one for internal tRPC routes."""

    cost: Optional[int] = 1
    r"""Expensive requests may use up more tokens. You can specify a cost to the request here and we'll deduct this many tokens in the current window.
    If there are not enough tokens left, the request is denied.

    Set it to 0 to receive the current limit without changing anything.
    """

    async_: Annotated[Optional[bool], pydantic.Field(alias="async")] = False
    r"""Async will return a response immediately, lowering latency at the cost of accuracy."""

    meta: Optional[Dict[str, Nullable[Any]]] = None
    r"""Attach any metadata to this request"""

    resources: Optional[List[Resources]] = None
    r"""Resources that are about to be accessed by the user"""


class LimitResponseBodyTypedDict(TypedDict):
    success: bool
    r"""Returns true if the request should be processed, false if it was rejected."""
    limit: int
    r"""How many requests are allowed within a window."""
    remaining: int
    r"""How many requests can still be made in the current window."""
    reset: int
    r"""A unix millisecond timestamp when the limits reset."""


class LimitResponseBody(BaseModel):
    success: bool
    r"""Returns true if the request should be processed, false if it was rejected."""

    limit: int
    r"""How many requests are allowed within a window."""

    remaining: int
    r"""How many requests can still be made in the current window."""

    reset: int
    r"""A unix millisecond timestamp when the limits reset."""


class LimitResponseTypedDict(TypedDict):
    http_meta: HTTPMetadataTypedDict
    object: NotRequired[LimitResponseBodyTypedDict]


class LimitResponse(BaseModel):
    http_meta: Annotated[Optional[HTTPMetadata], pydantic.Field(exclude=True)] = None

    object: Optional[LimitResponseBody] = None
