"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .httpmetadata import HTTPMetadata, HTTPMetadataTypedDict
import pydantic
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from unkey_py.types import BaseModel


class CreateIdentityRatelimitsTypedDict(TypedDict):
    name: str
    r"""The name of this limit. You will need to use this again when verifying a key."""
    limit: int
    r"""How many requests may pass within a given window before requests are rejected."""
    duration: int
    r"""The duration for each ratelimit window in milliseconds."""


class CreateIdentityRatelimits(BaseModel):
    name: str
    r"""The name of this limit. You will need to use this again when verifying a key."""

    limit: int
    r"""How many requests may pass within a given window before requests are rejected."""

    duration: int
    r"""The duration for each ratelimit window in milliseconds."""


class CreateIdentityRequestBodyTypedDict(TypedDict):
    external_id: str
    r"""The id of this identity in your system.

    This usually comes from your authentication provider and could be a userId, organisationId or even an email.
    It does not matter what you use, as long as it uniquely identifies something in your application.

    `externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.

    """
    meta: NotRequired[Dict[str, Any]]
    r"""Attach metadata to this identity that you need to have access to when verifying a key.

    This will be returned as part of the `verifyKey` response.

    """
    ratelimits: NotRequired[List[CreateIdentityRatelimitsTypedDict]]
    r"""Attach ratelimits to this identity.

    When verifying keys, you can specify which limits you want to use and all keys attached to this identity, will share the limits.
    """


class CreateIdentityRequestBody(BaseModel):
    external_id: Annotated[str, pydantic.Field(alias="externalId")]
    r"""The id of this identity in your system.

    This usually comes from your authentication provider and could be a userId, organisationId or even an email.
    It does not matter what you use, as long as it uniquely identifies something in your application.

    `externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.

    """

    meta: Optional[Dict[str, Any]] = None
    r"""Attach metadata to this identity that you need to have access to when verifying a key.

    This will be returned as part of the `verifyKey` response.

    """

    ratelimits: Optional[List[CreateIdentityRatelimits]] = None
    r"""Attach ratelimits to this identity.

    When verifying keys, you can specify which limits you want to use and all keys attached to this identity, will share the limits.
    """


class CreateIdentityResponseBodyTypedDict(TypedDict):
    r"""The configuration for an api"""

    identity_id: str
    r"""The id of the identity. Used internally, you do not need to store this."""


class CreateIdentityResponseBody(BaseModel):
    r"""The configuration for an api"""

    identity_id: Annotated[str, pydantic.Field(alias="identityId")]
    r"""The id of the identity. Used internally, you do not need to store this."""


class CreateIdentityResponseTypedDict(TypedDict):
    http_meta: HTTPMetadataTypedDict
    object: NotRequired[CreateIdentityResponseBodyTypedDict]
    r"""The configuration for an api"""


class CreateIdentityResponse(BaseModel):
    http_meta: Annotated[Optional[HTTPMetadata], pydantic.Field(exclude=True)] = None

    object: Optional[CreateIdentityResponseBody] = None
    r"""The configuration for an api"""
